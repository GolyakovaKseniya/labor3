# Задание 1
## Задача 10
### Текст задачи
Дороги. Измените сущности из задачи 1.3.3. Гарантируйте, что между двумя городами может быть только одна прямая дорога (другой путь может быть проложен только транзитом через другие города). Города можно создавать с указанием заранее заданных путей, в любой момент времени можно добавить новую дорогу в любой город и удалить имеющуюся дорогу.
### Алгоритм решения
Создаем 2 приватных поля: название города и интерфейс Map, хранящий набор путей (Город: цена до него) к следующим городам. Прописываем геттеры и сеттеры для названия и Map. Далее прописываем конструктор, который принимает название города, в нем инициализируем его и создаем реализацию Map (пустую карту): HashMap, с помощью нее можно быстро добавлять и искать элементы, однако она не гарантирует порядок (сортировку). Далее создаем метод, который будет добавлять город маршрута и стоимость в Map. В нем делаем проверку на стоимость, чтобы она не была отрицательной, и добавляем путь, проверяя при этом, чтобы путь не шел в город, в который мы его и добавляем. Так же по условию есть возможность удалять дороги, прописываем этот метод так же, как и метод добавления, кроме стоимости за дорогу. В методе toString выводим информацию в текстовом виде. Все проверки совершаются через выбрасывание исключений. В методе main даем выбор пользователю, что он хочет сделать. Если нужно создать город, то считываем название, создаем объект города с проверкой имени; если нужно создать город с заранее созданными путями, то также считываем название создаваемого города, количество путей для него, названия конечных городов и стоимость; если добавить дорогу: считываем два названия, учитываем, что они должны быть разными, стоимость и добавляем путь; если удалить, то тоже самое без стоимости.
#### Пример вывода
1) 
•	Вводим города A, B, C
Добавляем дорогу: А в В со стоимостью 2
Добавляем дорогу: С в А со стоимостью 1
Добавляем дорогу: B в C со стоимостью 2
Вывод: 
Город A : B{2}
Город B : C{2}
Город C : A{1}
•	Удалим дорогу между С и А
Вывод:
Город A : B{2}
Город B : C{2}
Город C : Дорог нет
•	Создадим город с заранее созданными путями:
Город D, с 2 путями: в В и в С
Вывод: 
Город A : B{2}
Город B : C{2}
Город C : Дорог нет 
Город D : B{1}, C{4}

•	2) Вводим города A, B, C
Добавляем дорогу: А в В со стоимостью -2
Вывод: Ошибка: Значение должно быть положительным
Добавляем дорогу: А в A
Вывод: Ошибка: Нельзя создать дорогу из города A в себя 

# Задание 3
## Задача 3
### Текст задачи
Двусторонняя дорога. Создайте такой подвид сущности Город, полученной в задаче 2.1.10, которая будет гарантировать, что при добавлении дороги из одного города в другой, одновременно будет добавляться и обратная дорога.
### Алгоритм решения
Создаем новый класс, который будет наследовать класс из задачи 1.10, сделаем его final, чтобы нельзя было его наследовать. Следовательно, прописывать поля, геттеры и сеттеры не нужно. Прописываем, конструктор, который будет передавать название города в родительский класс. Также делаем с методами, которые создают и удаляют дорогу. По условию нужно переопределить эти методы. Сначала проверяем валидны ли город и стоимость, далее смотрим не существует ли уже дорога, которую нужно создать и добавляем дорогу (одностороннюю), вызывая метод родительского класса. Так как в задаче создаем двустороннюю дорогу, то пользуемся методом, который передает название и стоимость в родительский класс, тем самым создается обратная дорога. Для удаления тоже самое, проверки, удаляем основную дорогу, а потом обратную. В методе toString, который нельзя будет переопределить, выводим информацию в текстовом виде. В методе main даем выбор пользователю, что он хочет сделать. Если нужно создать город, то считываем название, создаем объект города с проверкой имени; если нужно создать город с заранее созданными путями, то также считываем название создаваемого города, количество путей для него, названия конечных городов и стоимость; если добавить дорогу: считываем два названия, учитываем, что они должны быть разными, стоимость и добавляем путь; если удалить, то тоже самое без стоимости. 
#### Пример вывода
•	1) Вводим города A, B, C
Добавляем дорогу: А в В со стоимостью 2
Добавляем дорогу: С в А со стоимостью 1
Добавляем дорогу: B в C со стоимостью 2
Вывод: 
Город A : B{2}, C{1}
Город B : A{2}, C{2}
Город C : A{1}, B{2}
•	Удалим дорогу между С и А
Вывод:
Город A : B{2}
Город B : A{2}, C{2}
Город C : B{2}
•	Создадим город с заранее созданными путями:
Город D, с 2 путями: в В и в С
Вывод: 
Город A : B{2}
Город B : D{1}, A{2}, C{2}
Город C : D{2}, B{2}
Город D : B{1}, C{2}
•	2) Вводим города A, B, C
Добавляем дорогу: А в В со стоимостью -2
Вывод: Ошибка: Значение должно быть положительным
Добавляем дорогу: А в A
Вывод: Ошибка: Нельзя создать дорогу из города A в себя 


# Задание 3
## Задача 5
### Текст задачи
Трехмерная точка. Создайте такой подвид сущности Точка из задачи 1.1.1, которая будет иметь не две, а три координаты на плоскости: X,Y,Z.
### Алгоритм решения
Так как нужно создать подвид сущности Точка, тогда делаем новый класс наследником этой сущности так, чтобы уже его в свою очередь нельзя было наследовать. В подвиде точка создается тремя координатами, прописываем это поле, оно так же приватное и финальное, геттер для нее. Прописываем конструктор, в котором будут передаваться значения координат X и Y в родительский класс и присваивать значение новой Z координаты. В этой задаче переопределить получиться только метод toString, то есть возвращаем сразу значения координат, а не поля. В методе Main вводим три координаты для трех точек с проверкой и выводим их.
#### Пример вывода
1) 
Точка 1: 
Введите координату Х: -1,3
Введите координату Y: 0
Введите координату Z: 11
Точка 2: 
Введите координату Х: 0
Введите координату Y: 0
Введите координату Z: 0
Введите координату Х: -3
Введите координату Y: 0,99
Введите координату Z: 2
Вывод: 
Созданные точки: 
Точка 1: {-1.3;0.0;11.0}
Точка 2: {0.0;0.0;0.0}
Точка 3: {-3.0;0.99;2.0}
2) Введите координату Х: ваеннр
Вывод:
Ошибка, введите корректное число
Введите координату Х:

# Задание 4
## Задача 3
### Текст задачи
Птицы. Создайте сущность Птица, которая будет являться корнем иерархии для всех, кто является подвидом птицы. В разработанную сущность необходимо вынести все, что будет общим для птиц. Для того чтобы определить необходимые члены класса, проанализируйте три примера птиц:
 • Воробей. Умеет петь. При пении на экран выводится строка “чырык”. 
• Кукушка. Умеет петь. При пении на экран выводится текст“ку-ку”, причем текст выводится случайное количество раз в диапазоне от 1 до 10.
 • Попугай. Имеет текст и умеет петь этот текст. При инициализации обязательно необходимо указать текст, который будет исполняться. При пении текст выводится не весь, а первые N символов (не менее одного и не более всех символов текста), где N определяется случайно.
### Алгоритм решения
По условию задачи необходимо создать класс – корень иерархии, то есть нельзя будет создать объект непосредственно этого класса, только через наследование другим классам. В таком классе прописываем приватные поля: название птицы и метод рандома, конструктор инициализирует имя птицы, геттер и сеттер. Создаем абстрактный метод для пения птиц, он будет реализован в дочерних классах и метод для вывода птицы. Первым идет дочерний класс «Воробей», в конструкторе вызываем конструктор родительского класса, далее переопределяем абстрактный метод для пения, воробей должен петь «чырык». Далее класс «Кукушка», в конструкторе вызываем конструктор родительского класса, далее переопределяем абстрактный метод для пения, поет «ку-ку» случайное число раз от 1 до 10. И класс «Попугай», для него нет фиксированной фразы для пения, поэтому прописываем дополнительное поле для этого и геттер. Конструктор принимает поле, вызывает конструктор родительского класса. Переопределяем абстрактный метод для пения, в нем учитываем, что должен выводиться не весь текст: получаем случайное число, не превышающее длины текста, и извлекаем подстроку от начала до этого числа. В методе main даем пользователю выбор, какую птицу нужно создать, выбор пения птиц и демонстрация созданных птиц. Если нужно добавить какую-либо птицу, то для воробья и кукушки просто добавляем в список созданный объект класса, для попугая необходимо сначала ввести текст, который он будет петь. Если нужно вывести всех птиц, то проходим по списку и выводим по индексам каждую запись, если нужно вывести пение птиц, то проходим по каждому объекту и вызываем метод пения, если нужно послушать определенную птицу, то даем ввести ее номер, и выводим информацию по индексу.
#### Пример вывода
1)
•	Добавляем воробья, попугая
Введите текст для попугая: Привет, друг
•	Послушать пение всех птиц
Вывод: Воробей поет: чырык
Попугай поет: Привет, д
•	Показать всех птиц
Вывод: 
1 Я - Воробей
2 Я - Попугай, я пою: Привет, друг
•	Послушать конкретную птицу
1 Я - Воробей
2 Я - Попугай, я пою: Привет, друг
Выберите номер птицы: 1
Вывод: 
Воробей поет: чырык
2) 
•	Добавим кукушку
•	Послушать пение всех птиц
Вывод:
Воробей поет: чырык
Попугай поет: Привет, дру
Кукушка поет: ку-ку ку-ку ку-ку ку-ку ку-ку ку-ку ку-ку

# Задание 5
## Задача 9
### Текст задачи
Городим. Реализуйте граф показанный на рисунке, используя в одной и той же программе и сущности из задачи 2.1.10(односторонняя дорога)и сущности из задачи 2.3.3 (двусторонняя дорога) применяя их там, где это необходимо. На рисунке 66 односторонняя стрелка обозначает что возможно перемещение только в одном направлении (например только из пункта E в пункт C), а двусторонняя стрелка говорит о том, что возможно перемещение в обоих направлениях (например из Aв B и наоборот).
### Алгоритм решения
По условию задачи необходим интерфейс, который определяет, что должны делать города, но не как они это делают, прописываем туда геттеры, и методы для добавления и удаления дороги. Далее так как изначальные классы с городами не реализуют интерфейс, то создадим новые классы, которые будут это делать. В новых классах также есть геттеры, конструктор и метод для получения изначального объекта города. Прописываем метод для добавления дороги, в котором проверяем является ли город экземпляром необходимого класса, приводим к этому типу, что позволит использовать методы этого класса, и извлекаем оригинальный объект, чтобы можно было использовать оригинальные методы и свойства. Аналогичным образом работает удаление дороги. Также создаем метод, который будет проверять существует ли уже такая дорога. В методе main даем пользователю выбор для действий, все так же, как и в других задачах с городами. При создании дороги используется виртуальный вызов метода через интерфейс, то есть компилятор не знает заранее, какой метод будет вызываться. 
#### Пример вывода
1) 
•	1) Вводим города A, B, C
Добавляем дорогу: А в В со стоимостью 2 (двустороннюю)
Добавляем дорогу: С в А со стоимостью 1 (одностороннюю)
Добавляем дорогу: B в C со стоимостью 2 (двустороннюю)
Вывод:
A → B(2)
B → A(2), C(2)
C → A(1), B(2)

2) 
•	1) Вводим города A, B, C
Добавляем дорогу: А в A

Вывод:
Ошибка: Нельзя создать дорогу из города A в себя

# Задание 6
## Задача 5
### Текст задачи
Сравнение городов. Измените сущность Город, полученную в задаче 2.1.10. Переопределите метод сравнения объектов по состоянию таким образом, чтобы два Города считались одинаковыми тогда, когда у них одинаковый набор путей в другие города. Также, подвид Города из задачи 2.3.3 должен быть сравним с городом из задачи 2.1.10.
### Алгоритм решения
В готовую сущность сразу можно добавить переопределенный метод для сравнения. В нем смотрим, ссылается ли объект класса Object (то есть можно сравнить любые классы) на тот же объект, что и текущий, далее необходимо проверить, что он не нулевой и является экземпляром класса города. Потом приводим его к типу из задачи. И сравниваем пути городов. В методе main после ввода, используем метод сравнения получаем его результат и выводим его.
#### Пример вывода
1) Вводим односторонний город М с 2 дорогами в С (100) И В К (200) и город В (двусторонний) с 2 дорогами в С (100) И В К (200)
Вывод:
Город 1: Город M
  Дороги: {C=100, K=200}

Город 2: Город B
  Дороги: {C=100, K=200}

Результат сравнения: Города равны
Города имеют идентичный набор дорог

2) Вводим односторонний город М с 1 дорогой в С (100) и город В (двусторонний) с 2 дорогами в С (100) И В К (200)

Вывод:
Город 1: Город M
  Дороги: {C=100}
Город 2: Город B
  Дороги: {C=100, K=200}
Результат сравнения: Города разные
Наборы дорог различаются


# Задание 7
## Задача 1 и 2
### Текст задачи
Навести порядок. Данная задача предполагает реорганизацию ранее написанных классов. Расположите все ранее написанные классы по пакетам таким образом, чтобы логически близкие классы оказались сгруппированы друг с другом. Имена пакетов должны иметь как минимум трехсоставную форму, вида: ru.surname.type. Вместо surname следует подставить свою фамилию, а вместо type подставить название логического блока. Например, классы описывающие точку, линию, ломаную линию, фигуру, квадрат, треугольник, круг и прямоугольник можно расположить в пакете ru.surname.geometry.
Главный метод. Создайте пакет ru.surname.main (вместо surname необходимо подставить собственную фамилию) в котором расположить класс с точкой входа в исполнение программы (public static void main). Также следует проверить, что ни в одном другом пакете нет классов имеющих точку входа в исполнение программы. В этом же пакете необходимо расположить класс (или интерфейс) с методами из задач блока 2.5 и продемонстрировать их работоспособность.
### Алгоритм решения
Создаем пакеты по смыслу, получаем пакеты для задач про города, птиц, геометрию, исключения, проверки, main, и математика. В пакет main переносим интерфейс из пятого блока.
# Задание 7
## Задача 3
### Текст задачи
Возведение в степень. Создайте метод принимающий две строки, в которых будут записаны числа X и Y. Возвращает метод результат возведения X в степень Y. Для преобразования строки в число следует использовать метод Integer.parseInt, а для возведения в степень метод Math.pow. Вызовите разработанный метод передав туда параметры командной строки, полученные точкой входа в программу. Реализуйте метод так, чтобы для возведения в степень и преобразования строки использовались короткие имена статических методов.
### Алгоритм решения
По условию необходимо использовать короткие имена статистических методов, то есть их можно будет использовать без упоминания имени класса. Далее в методе преобразовываем строки в целые числа и вычисляем степень. В методе main просим ввести основание и показатель степени и выводим ответ.
#### Пример вывода
1) 
Введите основание X: -5
Введите показатель степени Y: 3
Ответ: 
-5 ^ 3 = -125.0
2) 
Введите основание X: 4
Введите показатель степени Y: 0
Ответ: 
4 ^ 0 = 1.0


# Задание 8
## Задача 4
### Текст задачи
Клонирование точки. Измените сущность Точка из 2.6.2. Переопределите метод клонирования, унаследованный от класса Object, таким образом, чтобы при его вызове возвращался новый объект Точки, значения полей которого будут копиями оригинальной Точки.
### Алгоритм решения
Так как нужно клонировать точку, то сделаем класс, который может реализовывать интерфейс клонирования, то есть можно будет использовать такой метод. Прописываем поля, геттеры, сеттеры как обычно. По условию нужны различные уровни доступа, package-private (только в этом пакете) и protected (в этом пакете и наследниках). Стандартный конструктор инициализирует координаты и устанавливает значения по умолчанию для полей доступа, во втором уже устанавливается значение для 1 поля, а в 3 конструкторе устанавливается значение для 2. Далее переопределяем метод клонирования, вызываем этот метод и приводим его к типу точки. Далее в методе main после ввода координат создаем новую точку с ними, потом клонируем всю информацию первой точки.
#### Пример вывода
1) 
Введите координату Х: -2
Введите координату Y: 0
Создана точка: {-2.0;0.0}
Создан клон: {-2.0;0.0}
Это разные объекты: true
Координаты одинаковы: true
2) 
Введите координату Х: -2,55
Введите координату Y: 11
Создана точка: {-2.55;11.0}
Создан клон: {-2.55;11.0}
Это разные объекты: true
Координаты одинаковы: true
